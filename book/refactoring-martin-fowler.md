# 📙 리팩토링: 코드 품질을 개선하는 객체지향 사고법
<img src="./RefactoringMartinFowler.jpg" width="300" alt="리팩토링: 코드 품질을 개선하는 객체지향 사고법">

이해한 내용을 기록하기 위해 글로 옮기는 것보다 책을 보는 것이 빠르다고 생각한 부분은 생략하였다.

1장에서 5장은 개요와 배경에 관한 내용이고 6장부터 본격적으로 리팩토링에 관한 내용이 언급된다.

<참고> : 자바는 정적 타입 언어라서, 리팩토링 할 때 컴파일러를 적극 활용하자 → 고치려는 코드 중 원본을 삭제하고 컴파일러가 알려주는 부분 수정본 추가하기

# **목차**

## **CHAPTER 01. 맛보기 예제**

- 원래의 프로그램
- 리팩토링 첫 단계
    - 리팩토링에서는 신뢰도가 높은 각종 테스트를 작성하는 것이 먼저다. 적절한 테스트 코드 작성이 리팩토링의 기보니다.
    - 테스트는 반드시 자체검사(→ CH 04)로 만들어야 한다.
- statement 메서드 분해와 기능 재분배
- 가격 책정 부분의 조건문 → 재정의로 교체
- 고찰
    - 맛보기 예제를 실습하면서 얻을 수 있는 가장 중요한 교훈은 ‘간단한 수정 → 테스트’를 리듬처럼 반복해야 한다는 것이다.

---

## **CHAPTER 02. 리팩토링 개론**

- 리팩토링은 무엇인가
    - 보통 두 가지로 쓰인다. 하나는 ‘겉으로 드러나는 기능은 그대로 둔 채, 알아보기 쉽고 수정하기 간편하게 소프트웨어 내부를 수정하는 작업’이다. 다른 하나는 ‘리팩토링 기법을 연달아 적용해서 겉으로 드러나는 기능은 그대로 둔 채 소프트웨어 구조를 변경하는 작업’이다.
- 리팩토링은 왜 해야 하나
    - 소프트웨어 설계가 개선되니까
    - 소프트웨어를 이해하기 더 쉬워지니까
    - 버그를 찾기가 쉬워지니까
    - 프로그래밍 속도가 빨라지니까
- 리팩토링은 언제 필요한가
    - 같은 작업의 삼진 아웃 때
    - 기능을 추가할 때
    - 버그를 수정할 때
    - 코드를 검수할 때
- 팀장에게 어떻게 말을 꺼내나
- 리팩토링 관련 문제들
    - 리팩토링하면 안 되는 상황도 있다. 대표적으로 코드를 처음부터 새로 작성해야 할 때다. 혹은 기간이 임박했을 때이다.
- 리팩토링과 설계
- 리팩토링과 성능
    - 성능과 관련하여 재밌는 사실이 있다. 대부분의 프로그램을 분석할 때 개발자는 90%는 거의 실행될 일 없는 작은 코드 조각에 얽매여 많은 시간을 낭비하는 것이다. 프로그램을 빠르게 하려고 매달린 시간도 낭비되고, 코드의 명료성이 떨어진 만큼의 시간도 허비된다.
        - 테스트 코드 작성할 때, 개발할 때, 리팩토링할 때, 성능 향상할 때. 상황을 나누어 목적에 맞게 작업하는 것이 시간을 줄이는 것 같다.
- 리팩토링의 유래
    - 유능한 프로그래머들은 깔끔한 코드가 복잡하고 정신없는 코드에 비해 나중에 수정하기 편하다는 것을 경험을 통해 알고 있기 때문에, 초반부터 깔끔한 코드를 작성하기란 거의 불가능하다는 것을 알고 있다.

---

## **CHAPTER 03. 코드의 악취(Code Smells)**

- 중복 코드 (Duplicated Code)
- 장황한 메서드 (Long Method)
- 방대한 클래스 (Large Class)
- 긴 매개변수 목록 (Long Parameter List)
- 수정의 산발 (Divergent Change)
- 기능의 산재 (Shotgun Surgery)
- 잘못된 소속 (Feature Envy)
- 데이터 뭉치 (Data Clumps)
- 기본 타입 집착 (Primitive Obsession)
- switch 문 (Switch Statements)
- 평행 상속 계층 (Parallel Inheritance Hierarchies)
- 직무유기 클래스 (Lazy Class)
- 막연한 범용 코드 (Speculative Generality)
- 임시 필드 (Temporary Field)
- 메시지 체인 (Message Chains)
- 과잉 중개 메서드 (Middle Man)
- 지나친 관여 (Inappropriate Intimacy)
- 인터페이스가 다른 대용 클래스
- 미흡한 라이브러리 클래스
- 데이터 클래스
- 방치된 상속물
- 불필요한 주석

---

## **CHAPTER 04. 테스트 작성**

- 자가 테스트 코드의 가치
    - 테스트 작성하기 가장 적합한 시점 중 하나는 프로그래밍을 시작할 때다. 기능을 추가할 때는 테스트부터 우선 작성하자.
        - 자가 테스트: 자동화 된 단위(유닛) 테스트
        - 리팩토링 과정에서 안전망이 되고,  수동으로 확인하는 시간 낭비를 없애주고, 테스트가 실패하면 즉각 피드백을 주는 장점 존재
- JUnit 테스트 프레임워크
- 테스트 추가
    - 테스트는 위험을 위주로 작성해야 한다. 읽고 쓰는 기능 뿐인 간단해서 버그가 있을 확률이 거의 없는 메서드는 테스트하지 않는다. 테스트 작성 대상에서 제외시키는 편이 좋다.
    - 테스트를 위해 해야 할 산더미 같은 작업에 대한 생각으로 압박을 느낄 수 있다. 완벽을 추구하게 되고, 부담감에 짓눌려 의지를 잃을 수도 있다. 따라서 엄청난 테스트 작성을 계획하는 것은 비생산적이다. 잘못될까봐 가장 걱정되는 부분들만 테스트해야 한다. 그래야 테스트 수고 대비 최대 효과를 얻을 수 있다.
        - 간단한 성공 케이스, 실패 케이스 한 두개만 추가하고 보완하는 리듬으로 개발하면 좋을 것 같다.
    - 모든 버그를 잡아내려고 며칠을 낭비할 바에 적당한 시간을 들여 대부분의 버그를 잡아내는 것이 낫다.

---

## **CHAPTER 05. 리팩토링 기법 카탈로그 개요**

- 참조 검색
- 리팩토링 기법의 성숙도

참고 : 카탈로그 형식의 6장부터 12장은 필자가 초기에 정리한 리팩토링 기법을 하나씩 체계적으로 설명한다.

각 리팩토링 기법은 이름, 요약, 동기, 방법, 예제와 같은 하위 절로 구성된다.

‘2장 리팩토링은 무엇인가’에서 언급됐듯이, 하나의 리팩토링 기법은 여러 개의 다른 리팩토링 기법들과 연관되어 있다.

---

## **CHAPTER 06. 메서드 정리(Methods)**

리팩토링의 주된 작업은 코드를 포장하는 메서드를 적절히 정리하는 것이다. 거의 모든 문제점은 장황한 메서드로 인해 생긴다.

- 메서드 추출 (Extract Method)
    - 메서드가 너무 길거나 코드에 주석을 달아야만 의도를 이해할 수 있을 때, 별도의 메서드로 추출한다.
    - 적당한 메서드의 길이는 중요하지 않다. 중요한 것은 메서드명과 메서드 내용의 의미적 차이다. 메서드 추출로 코드의 **명료성이 향상**되기만 한다면, 메서드명이 추출한 코드보다 길어도 메서드를 추출한다. 원리가 아니라 기능으로 이름 지어야 한다.
    - 지역 변수가 엮인 부분을 메서드로 추출할 때, 변수를 두 개 이상 반환해야 할 땐 어쩌지?
        - 최선의 방법은 다른 부분의 코드를 빼내는 것이다. 메서드가 하나의 값만 반환하게끔 한다.
        - 임시변수가 너무 많으면 추출하기 아주 어려울 수 있다. 이럴 땐 **`임시변수를 메서드 호출로 전환`** 기법을 실시해서 임시변수의 수를 줄이자.
        - 그래도 힘들다면 `메서드 객체로 전환` 기법을 실시하자.
- 메서드 내용 직접 삽입 (Inline Method)
    - 메서드 기능이 너무 단순해서 뻔할 때는 분리하지 않는다. 분리된 메서드는 호출하는 메서드에 넣어버리고 삭제한다. 과도한 인다이렉션과 단순한 위임은 불필요하다.
    - 켄트 벡은 `메서드를 메서드 객체로 전환` 기법을 적용하기 전 이 기법을 실시하면 좋을 때가 많다고 한다.
- 임시변수 내용 직접 삽입 (Inline Temp)
    - 이 기법은 `임시변수를 메서드 호출로 전환` 기법을 실시해야 하는 동기라고 할 수 있다.
    - 임시 변수가 메서드 호출의 결과값이 대입될 때는 문제가 없지만, 메서드 추출 등 다른 리팩토링에 방해가 된다면 임시변수를 제거하고 내용을 직접 삽입하자. → 이 때 임시 변수에 `final` 키워드를 한 번 붙여보면 좋다, 재할당 확인용으로.
- 임시변수를 메서드 호출로 전환 (Replace Temp with Query)
    - 임시변수는 일시적이고, 적용이 국소적이다. 메서드 호출로 임시변수를 전환하면 클래스 안 모든 메서드가 그 정보에 접근할 수 있다. → 이 때 임시 변수에 `final` 키워드를 한 번 붙여보면 좋다, 재할당 확인용으로.
    - 성능이 염려될 수 있지만, 대체로 문제 없다. 문제가 된다 해도 최적화 과정에서 해결하면 되고, 최악의 경우 임시변수를 다시 넣는 일은 간단하다.
    - 이 기법은 대부분의 경우, `메서드 추출`을  적용하기 전 반드시 적용한다. 지역변수가 많을 수록 메서드 추출이 힘들어지기 때문이다.
    - 복잡한 리팩토링의 경우, `임시변수 분리`나 `상태 변경 메서드와 값 반환 메서드를 분리(10장, 331p)`를 먼저 적용해야 할 때도 있다.
- 직관적 임시변수 추가 (Introduce Explaining Variable)
    - 수식이 너무 복잡해져서 이해하기 힘들 때는 과감하게 임시변수를 사용하자. 단, 생각없이 남용하면 안 된다.
    - `메서드 추출` 을 선호하여 사용하자. 임시변수보다 메서드가 재활용하기 좋다. 어쩔 수 없이 지역변수가 많이 사용될 때는 임시변수를 사용하자.
- 임시변수 분리 (Split Temporary Variable)
    - 임시변수의 용도는 다양하다. 임시변수에 값이 여러 번 대입될 때, 그 경우(루프 변수나 값 누적용 임시변수가 아닌 경우)가 계산 결과를 나중에 참조하기 위함이라면 임시변수를 여러 개로 분리해야 한다. 임시변수 하나로 두 가지 이상의 용도로 사용하면 코드를 읽는 사람에게 혼동을 줄 수 있다.
- 매개변수 대입 제거 (Remove Assignments to Parameters)
    
    ```java
    int do(int a, int b) {
          if (a > b) a = b;
          return a;
    }
    
    int do(int a, int b) {
          int result = a;
          if (a > b) result = b;
          return result;
    }
    ```
    
- 메서드를 메서드 객체로 전환 (Method Object)
    - 지역변수가 많으면 `메서드 추출`이 어려울 수 있다. `임시변수를 메서드 호출로 전환` 기법을 적용하면 이런 어려움이 해소되지만, 메서드를 분해할 수 없을 때도 있다.
    - 모든 지역변수가 메서드 객체의 속성이 된다. 새로 만든 메서드 객체에 `메서드 추출`을 적용해서 원래의 메서드를 쪼개어 여러 개의 추가 메서드를 만든다.
    - 171p - 173p : Class A { calculate() } → Class Calculate { A, …, do() } ⇒ a.calculate() → calculate.do(), calculate() { new Calculate().do() } ⇒⇒⇒ 인다리엑션 활용하여 초점 변경
- 알고리즘 전환 (Substitute Algorithm)

---

## **CHAPTER 07. 객체 간 기능 이동**

객체 설계에서 원칙은 아니지만 가장 중요한 일 중 하나가 ‘기능을 어디에 넣을지 판단’하는 것이다.

마지막 두 개의 리팩토링 기법 `외래 클래스에 메서드 추가`, `국소적 상속 확장 클래스 사용` 은 특수 케이스다. 클래스의 원본 코드에 접근할 수 없는 상황에서 이 수정 불가능한 클래스로 기능을 이동해야 할 때만 실시한다. 메서드가 한 두개 뿐일 때는 `전자`, 세 개 이상일 땐 `후자를` 실시한다.

- 메서드 이동 (Move Method)
    - 원본 클래스의 기능을 사용하려면 : (그 기능을 대상 클래스로 옮기자), (대상 클래스에서 원본 클래스로의 참조를 생성하거나 사용하자), (원본 객체를 대상 객체에 매개변수로 전달하자), (그 기능이 변수라면 그 변수를 매개변수로 전달하자)
- 필드 이동 (Move Field)
- 클래스 추출 (Extract Class)
    - 데이터의 일부분과 메서드의 일부분이 한 덩어리이거나, 함께 변화하거나 서로 유난히 의존적인 데이터의 일부분도 클래스로 떼어내기 좋다.
- 클래스 내용 직접 삽입 (Inline Class)
    - 클래스에 남은 기능이 거의 없으면 클래스를 합쳐버리자.
- 대리 객체 은폐 (Hide Delegate)
    - 디미터의 법칙처럼, john.getClass().getTeacher()보단 john.getClassTeacher()로 사용하기
- 중개 메서드 제거 (Remove Middle Man)
    - 대리 객체 은폐의 반대. john.getClassTeacher()과 같은 위임 메서드가 많을 때는 적절한 판단에 따라 대리 객체를 거치게끔 수정하자.
- 외래 클래스에 메서드 추가
    - 현재 사용 중인 클래스에 한 가지 기능이 필요해졌다. 이 기능을 원본 클래스(서버)에 추가가능하다면 추가하면 되지만, 추가가 안 된다면? 클라이언트 클래스에 기능을 추가한다, 이 기능이 여러 번 사용된다면.
- 국소적 상속 확장 클래스 사용
    - 클래스를 하나 만드는 방법인데, 상속을 통해 클래스를 만들어 기능을 추가하는 방법과 위임, 합성을 통해 래퍼 클래스를 만들어서 기능을 추가하는 방법이 있다.

---

## **CHAPTER 08. 데이터 체계화**

- 필드 자체 캡슐화
- 데이터 값을 객체로 전환
    - 변수나 메서드를 추가하려는데 코드의 구린내가 날 때, 데이터 값을 객체로 만들자. String customer → Customer customer
- 값 → 참조 전환
    - 값 객체와 참조 객체는 동등성(equality)과 동일성(identical)을 생각하면 된다. 예를 들어 money와 value와 같이 두 객체의 값이 같다면 객체가 동등하다. id값처럼 식별값이 하나 더 필요한 것은 참조객체, 동일성.
    - 참조 객체를 반환하는 팩토리 메서드와 참조 객체로의 접근을 담당할 객체를 만들자.
- 참조 → 값 전환
    - equals(), hash() 작성하기.
- 배열 → 객체 전환
- 관측 데이터 복제 : 일단 pass
- 단방향 → 양방향 전환
- 양방향 → 단방향 전환
- 마법 숫자 → 상수
- 필드 캡슐화
- 컬렉션 캡슐화
    - 메서드가 컬렉션을 반환한다면, 객체의 캡슐화가 깨진다. 컬렉션을 객체 내부에서 꺼내면 객체 외부에 구조를 노출하게 되고, 컬렉션에 무슨 일이 일어날 지 모른다. 그렇기에, 읽기 메서드는 수정 불가능한 컬렉션을 주게하고, 쓰기 메서드는 지운다. 추가/삭제 메서드를 만들어서 객채 내부에서 컬렉션에 작업하도록 만든다.
- 레코드 → 데이터 클래스
- 분류 부호 → 클래스
    - 혈액형처럼 종류가 여러 가지라면 컴파일러가 구분가능한 클래스의 객체(enum클래스처럼)로 만들자.
- 분류 부호 → 하위 클래스
    - 분류 부호가 클래스에 영향을 준다면 재정의를 통해 다르게 처리할 수 있다. 혈액형 별로 검사받는 날짜가 1,2,3,4처럼 다르다면? 재정의를 통해 해결한다.
- 분류 부호 → 상태/전략 패턴
    - `분류 부호 → 하위 클래스`처럼 상속을 통해 해결할 수도 있지만, 합성을 통해 해결할 수도 있다. 상속과 달리 런타임 중 객체를 갈아끼울 수 있는 장점이 존재한다.
- 하위클래스 → 필드
    - 객체가 남자냐 여자냐의 다형성을 상속(재정의)을 통해 구현했지만 너무 간단한 기능이라면, 그냥 객체의 필드로 추가한다. isMale() → true/false

---

## **CHAPTER 09. 조건문 간결화**

객체지향 프로그램에는 switch-case문이 거의 들어있지 않다. 이것들은 전부 재정의로 전환을 적용해야 한다.

- 조건문 쪼개기
    - 간단한 메서드라도 분리하여 의도를 쉽게 파악할 수 있다면 빼내자. (책의 필자는 명료함을 근거로 리팩토링을 하고 있다.)
- 중복 조건식 통합
- 조건문의 공통 코드 추출
- 제어 플래그 제거
    - 제어 플래그 대신 break, return문을 활용하자. 그리고, break나 continue문이 있더라도 메서드 추출 후 return문으로 바꾸는 것이 좋다. return문 뒤에 더 이상 실행할 코드가 없음을 명시적으로 알 수 있기 때문이다.
- 다중 조건문 → 가드 절(감시 절)
- 조건문 → 다형성 (조건문을 재정의로 전환)
    - 상속 혹은 위임(상태/전략 패턴)을 통해 다형성 만족시키기.
- Null Object 패턴
    - 중복되는 로직 null검사와 처리를 널 객체로 대체할 수 있다.
- 어설션 추가

---

## **CHAPTER 10. 메서드 호출 단순화**

- 메서드명 변경
- 매개변수 추가/제거
- 상태 변경 메서드와 쿼리(값 반환) 메서드 분리
- 메서드 파라미터화
- 매개변수를 명시적 메서드로 대체
    - 일반적으로 하나의 매개변수의 값으로 여러 개가 될 수 있을 때 조건문은 없애고 메서드로 작성하는 게 좋다. Employee.create(SALESMAN) → Employee.createSalesman();
- 객체를 통째로 전달
- 매개변수 세트 → 메서드
- 매개변수 세트 → 객체
- Setter 제거
- 메서드 은폐
- 생성자 → 팩토리 메서드
- 하향 타입 변환 캡슐화
- 에러 코드 → 예외
- 예외 → 테스트
    - try-catch문 남용하지 말자. 예기치 못한 일이 아닌, 예상 가능한 경우는 적절하게 처리해야 한다.

---

## **CHAPTER 11. 일반화(Generalization)**

- 필드 상향
- 메서드 상향
- 생성자 내용 상향
- 메서드 하향
- 필드 하향
- 하위클래스 추출
- 상위클래스 추출
- 인터페이스 추출
- 계층 병합
- 템플릿 메서드 형성
- 상속 → 위임
- 위임 → 상속

---

## **CHAPTER 12. 복합 리팩토링**

- 상속 구조 정리
- 절차 코드 → 객체로
- 도메인 로직과 표현 분리
- 계층구조 추출

---

## **CHAPTER 13. 리팩토링, 재사용, 현실성**

- 개발자가 리팩토링을 꺼리는 이유
- 현실성 재검토
- 리팩토링 자료·참고문헌
- 소프트웨어 재사용과 기술 변경 영향
- 끝 인사

---

## **CHAPTER 14. 리팩토링 도구**

- 도구를 이용한 리팩토링
- 리팩토링 도구의 기술적 요건
- 리팩토링 도구의 실무적 요건
- 맺음말

---